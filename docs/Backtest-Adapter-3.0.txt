// @version=5
strategy("Backtest Adapter 3.0",
     overlay=true,
     scale=scale.right,
     calc_on_every_tick=true,
     initial_capital=100000)

// === Inputs ===
useDateFilter = input.bool(true, title="Begin Backtest at Start Date", group="Backtest Time Period")
backtestStartDate = input.time(timestamp("11 May 2022"), title="Start Date", group="Backtest Time Period")

src = input.source(title="Source", defval=close, tooltip="Signal input (from classifier)", group="General Settings")

// === Internal Settings (Fixed Values) ===
// Risk Management
riskPercent = 0.10  // 10% risk per trade
atrPeriod = 14
atrMultiplier = 2.0

// Sharpe Calculation
riskFreeRate = 0.0  // 0% risk-free rate

// Override Settings
volRatioThreshold = 1.5
momentumAtrThreshold = 0.15
maxBarsInTrade = 8
maxRideTimeHours = 8
accountDrawdownLimit = 0.70

// === NEW: Tiered Take Profit Settings ===
// Tiered TP configuration - 3 tiers with 100% coverage (matching Python bot)
useTieredTP = true
tp1_atr_multiplier = 1.5
tp1_percentage = 0.35
tp2_atr_multiplier = 2.5
tp2_percentage = 0.35
tp3_atr_multiplier = 4.0
tp3_percentage = 0.30

// Validate total percentage equals 100%
tp_total_percentage = tp1_percentage + tp2_percentage + tp3_percentage
tp_validation_error = math.abs(tp_total_percentage - 1.0) > 0.001

// === NEW: Tiered Take Profit State Variables ===
// Tiered TP tracking for long positions
var float long_tp1_price = na
var float long_tp2_price = na
var float long_tp3_price = na
var bool long_tp1_hit = false
var bool long_tp2_hit = false
var bool long_tp3_hit = false
var float long_remaining_size = na

// Tiered TP tracking for short positions
var float short_tp1_price = na
var float short_tp2_price = na
var float short_tp3_price = na
var bool short_tp1_hit = false
var bool short_tp2_hit = false
var bool short_tp3_hit = false
var float short_remaining_size = na

// === NEW: Alert ID Management System ===
// Position tracking variables
var string currentLongAlertId = na
var string currentShortAlertId = na
var bool longPositionOpen = false
var bool shortPositionOpen = false
var float longEntryPrice = na
var float shortEntryPrice = na
var int longEntryBarIndex = na
var int shortEntryBarIndex = na

// Alert message parsing function
parseAlertMessage(message) =>
    if na(message)
        [na, na, na]
    else
        parts = str.split(message, "|")
        if array.size(parts) >= 3
            signalType = array.get(parts, 0)
            alertId = array.get(parts, 1)
            symbol = array.get(parts, 2)
            timeframe = array.get(parts, 3)
            [signalType, alertId, symbol]
        else
            [na, na, na]

// === Script Logic ===
inTradeWindow = not useDateFilter or time >= backtestStartDate
atrValue = ta.atr(atrPeriod)

// Indicator calculations moved out of conditional blocks for consistency
volRatio = ta.atr(14) / ta.atr(100)
sma10 = ta.sma(close, 10)

// === State Management Variables ===
var bool overrideFired = false
var float initialRiskInCurrency = 0.0
var int entryBarIndex = na // OPTIMIZATION: Variable to track entry bar

// Reset state if flat
if strategy.position_size == 0
    overrideFired := false
    initialRiskInCurrency := 0.0
    entryBarIndex := na // OPTIMIZATION: Reset entry bar index
    // Reset position tracking
    longPositionOpen := false
    shortPositionOpen := false
    currentLongAlertId := na
    currentShortAlertId := na
    
    // === NEW: Reset Tiered TP Variables ===
    long_tp1_price := na
    long_tp2_price := na
    long_tp3_price := na
    long_tp1_hit := false
    long_tp2_hit := false
    long_tp3_hit := false
    long_remaining_size := na
    
    short_tp1_price := na
    short_tp2_price := na
    short_tp3_price := na
    short_tp1_hit := false
    short_tp2_hit := false
    short_tp3_hit := false
    short_remaining_size := na

// === NEW: Alert-Based Trading Logic ===
// Parse the source as alert message (assuming src contains the alert message)
alertMessage = str.tostring(src)
[signalType, alertId, symbol] = parseAlertMessage(alertMessage)

// === NEW: Direct Signal Value Processing ===
// Handle case where src contains direct signal values (1, -1, 0) instead of alert messages
var float directSignal = na
if na(signalType) and not na(src)
    // Try to convert src to a number (direct signal value)
    directSignal := math.round(src)
    
    // Map direct signal values to signal types
    if directSignal == 1
        signalType := "LONG_ENTRY"
        alertId := "DIRECT_" + str.tostring(bar_index)
        symbol := syminfo.ticker
    else if directSignal == -1
        signalType := "SHORT_ENTRY"
        alertId := "DIRECT_" + str.tostring(bar_index)
        symbol := syminfo.ticker
    else if directSignal == 0
        if strategy.position_size > 0
            signalType := "CLOSE_LONG"
            alertId := "DIRECT_" + str.tostring(bar_index)
            symbol := syminfo.ticker
        else if strategy.position_size < 0
            signalType := "CLOSE_SHORT"
            alertId := "DIRECT_" + str.tostring(bar_index)
            symbol := syminfo.ticker

// Trading logic based on alert messages OR direct signals
startLongTrade = signalType == "LONG_ENTRY"
endLongTrade = signalType == "CLOSE_LONG"
startShortTrade = signalType == "SHORT_ENTRY"
endShortTrade = signalType == "CLOSE_SHORT"

// === NEW: Early Flip Detection Logic ===
// Track signal changes using the same logic as the original Lorentzian indicator
var int signal = 0
var int barsHeld = 0

// Update signal state (same as original indicator)
signal := startLongTrade ? 1 : startShortTrade ? -1 : (endLongTrade or endShortTrade) ? 0 : nz(signal[1])

// Bar-count filters (same as original indicator)
barsHeld := ta.change(signal) != 0 ? 0 : barsHeld + 1

// Early flip detection (same as original indicator)
// An early flip occurs if the signal changes now, and it also changed within the previous 3 bars
isEarlySignalFlip = ta.change(signal) != 0 and (ta.change(signal[1]) != 0 or ta.change(signal[2]) != 0 or ta.change(signal[3]) != 0)

// Count total early flips
var int totalEarlyFlips = 0
if isEarlySignalFlip and inTradeWindow
    totalEarlyFlips := totalEarlyFlips + 1
// === END of NEW Logic ===

// --- Enhanced Position Sizing and Entry ---
if inTradeWindow and strategy.position_size == 0
    // Long Entry
    if startLongTrade and not longPositionOpen
        stopLossPrice = close - (atrValue * atrMultiplier)
        riskPerShare = close - stopLossPrice
        if riskPerShare > 0
            var float positionSize = (strategy.equity * riskPercent) / riskPerShare
            initialRiskInCurrency := positionSize * riskPerShare
            entryBarIndex := bar_index // OPTIMIZATION: Record entry bar index
            
            // Update position tracking
            longPositionOpen := true
            currentLongAlertId := alertId
            longEntryPrice := close
            longEntryBarIndex := bar_index
            
            // === NEW: Setup Tiered Take Profit Levels for Long ===
            if useTieredTP and not tp_validation_error
                long_tp1_price := close + (atrValue * tp1_atr_multiplier)
                long_tp2_price := close + (atrValue * tp2_atr_multiplier)
                long_tp3_price := close + (atrValue * tp3_atr_multiplier)
                long_tp1_hit := false
                long_tp2_hit := false
                long_tp3_hit := false
                long_remaining_size := positionSize
                label.new(bar_index, long_tp1_price, "TP1\n" + str.tostring(tp1_percentage * 100, "#") + "%", color=color.blue, style=label.style_label_down, textcolor=color.white)
                label.new(bar_index, long_tp2_price, "TP2\n" + str.tostring(tp2_percentage * 100, "#") + "%", color=color.blue, style=label.style_label_down, textcolor=color.white)
                label.new(bar_index, long_tp3_price, "TP3\n" + str.tostring(tp3_percentage * 100, "#") + "%", color=color.blue, style=label.style_label_down, textcolor=color.white)
            
            strategy.entry("Enter Long", strategy.long, qty=positionSize)
            strategy.exit("Exit Long", "Enter Long", stop=stopLossPrice)

    // Short Entry
    if startShortTrade and not shortPositionOpen
        stopLossPrice = close + (atrValue * atrMultiplier)
        riskPerShare = stopLossPrice - close
        if riskPerShare > 0
            var float positionSize = (strategy.equity * riskPercent) / riskPerShare
            initialRiskInCurrency := positionSize * riskPerShare
            entryBarIndex := bar_index // OPTIMIZATION: Record entry bar index
            
            // Update position tracking
            shortPositionOpen := true
            currentShortAlertId := alertId
            shortEntryPrice := close
            shortEntryBarIndex := bar_index
            
            // === NEW: Setup Tiered Take Profit Levels for Short ===
            if useTieredTP and not tp_validation_error
                short_tp1_price := close - (atrValue * tp1_atr_multiplier)
                short_tp2_price := close - (atrValue * tp2_atr_multiplier)
                short_tp3_price := close - (atrValue * tp3_atr_multiplier)
                short_tp1_hit := false
                short_tp2_hit := false
                short_tp3_hit := false
                short_remaining_size := positionSize
                label.new(bar_index, short_tp1_price, "TP1\n" + str.tostring(tp1_percentage * 100, "#") + "%", color=color.red, style=label.style_label_up, textcolor=color.white)
                label.new(bar_index, short_tp2_price, "TP2\n" + str.tostring(tp2_percentage * 100, "#") + "%", color=color.red, style=label.style_label_up, textcolor=color.white)
                label.new(bar_index, short_tp3_price, "TP3\n" + str.tostring(tp3_percentage * 100, "#") + "%", color=color.red, style=label.style_label_up, textcolor=color.white)
            
            strategy.entry("Enter Short", strategy.short, qty=positionSize)
            strategy.exit("Exit Short", "Enter Short", stop=stopLossPrice)

// --- Enhanced Exit Logic with Python Bot Parity ---
if strategy.position_size != 0 and not overrideFired
    // Risk Control 1: Account Drawdown Check
    currentDrawdown = math.abs(strategy.max_drawdown) / strategy.initial_capital
    if currentDrawdown > accountDrawdownLimit
        strategy.close_all(comment="Account drawdown limit exceeded")
        overrideFired := true
    
    // Risk Control 2: Maximum Ride Time Check (Dynamic based on timeframe)
    var int maxRideBars = na
    if na(maxRideBars)
        if timeframe.isintraday and timeframe.multiplier <= 15
            maxRideBars := maxRideTimeHours * 4  // 15M: 8 hours = 32 bars
        else if timeframe.isintraday and timeframe.multiplier <= 60
            maxRideBars := maxRideTimeHours  // 1H: 8 hours = 8 bars
        else
            maxRideBars := maxRideTimeHours / 4  // 4H: 8 hours = 2 bars
    
    // Use appropriate entry bar index based on position type
    currentEntryBarIndex = strategy.position_size > 0 ? longEntryBarIndex : shortEntryBarIndex
    barsHeld = bar_index - currentEntryBarIndex
    if barsHeld > maxRideBars
        strategy.close_all(comment="Maximum ride time exceeded")
        overrideFired := true
    
    // For an open Long position
    if endLongTrade and strategy.position_size > 0 and not overrideFired and longPositionOpen
        bool isProfitableEnough = strategy.openprofit >= initialRiskInCurrency
        bool isTrending = signalType == "LONG_ENTRY"
        bool isVolOK = volRatio < volRatioThreshold
        bool isMomentumStrong = (close - sma10) / atrValue > momentumAtrThreshold
        
        bool shouldOverride = isProfitableEnough and (isTrending or isVolOK) and isMomentumStrong

        if shouldOverride
            overrideFired := true
            // Timeframe-specific ATR multipliers (matching Python bot)
            slMultiplier = timeframe.isintraday and timeframe.multiplier <= 15 ? 1.5 : 2.0
            tpMultiplier = 4.0  // Far TP as backup (tiered TP handles actual exits)
            newStopLoss = close - (atrValue * slMultiplier)
            newTakeProfit = close + (atrValue * tpMultiplier)
            strategy.exit("Exit Long", from_entry="Enter Long", loss=newStopLoss, limit=newTakeProfit)
        else
            strategy.close("Enter Long", comment="Normal Close")
            // Update position tracking
            longPositionOpen := false
            currentLongAlertId := na

    // For an open Short position
    if endShortTrade and strategy.position_size < 0 and not overrideFired and shortPositionOpen
        bool isProfitableEnough = strategy.openprofit >= initialRiskInCurrency
        bool isTrending = signalType == "SHORT_ENTRY"
        bool isVolOK = volRatio < volRatioThreshold
        bool isMomentumStrong = (sma10 - close) / atrValue > momentumAtrThreshold

        bool shouldOverride = isProfitableEnough and (isTrending or isVolOK) and isMomentumStrong

        if shouldOverride
            overrideFired := true
            // Timeframe-specific ATR multipliers (matching Python bot)
            slMultiplier = timeframe.isintraday and timeframe.multiplier <= 15 ? 1.5 : 2.0
            tpMultiplier = 4.0  // Far TP as backup (tiered TP handles actual exits)
            newStopLoss = close + (atrValue * slMultiplier)
            newTakeProfit = close - (atrValue * tpMultiplier)
            strategy.exit("Exit Short", from_entry="Enter Short", loss=newStopLoss, limit=newTakeProfit)
        else
            strategy.close("Enter Short", comment="Normal Close")
            // Update position tracking
            shortPositionOpen := false
            currentShortAlertId := na

// === NEW: Tiered Take Profit Execution Logic ===
if useTieredTP and not tp_validation_error
    // Check Long Position Tiered TP Triggers
    if longPositionOpen and strategy.position_size > 0
        // TP1 Check
        if not long_tp1_hit and high >= long_tp1_price
            long_tp1_hit := true
            qty_to_exit = strategy.position_size * tp1_percentage
            strategy.order("TP1 Long", strategy.short, qty=qty_to_exit, comment="TP1 Exit")
            long_remaining_size := strategy.position_size - qty_to_exit
            label.new(bar_index, high, "TP1 HIT\n" + str.tostring(qty_to_exit, "#"), color=color.green, style=label.style_label_down, textcolor=color.white)
        
        // TP2 Check
        if long_tp1_hit and not long_tp2_hit and high >= long_tp2_price
            long_tp2_hit := true
            qty_to_exit = strategy.position_size * tp2_percentage
            strategy.order("TP2 Long", strategy.short, qty=qty_to_exit, comment="TP2 Exit")
            long_remaining_size := strategy.position_size - qty_to_exit
            label.new(bar_index, high, "TP2 HIT\n" + str.tostring(qty_to_exit, "#"), color=color.green, style=label.style_label_down, textcolor=color.white)
        
        // TP3 Check
        if long_tp2_hit and not long_tp3_hit and high >= long_tp3_price
            long_tp3_hit := true
            qty_to_exit = strategy.position_size * tp3_percentage
            strategy.order("TP3 Long", strategy.short, qty=qty_to_exit, comment="TP3 Exit")
            long_remaining_size := strategy.position_size - qty_to_exit
            label.new(bar_index, high, "TP3 HIT\n" + str.tostring(qty_to_exit, "#"), color=color.green, style=label.style_label_down, textcolor=color.white)
    
    // Check Short Position Tiered TP Triggers
    if shortPositionOpen and strategy.position_size < 0
        // TP1 Check
        if not short_tp1_hit and low <= short_tp1_price
            short_tp1_hit := true
            qty_to_exit = math.abs(strategy.position_size) * tp1_percentage
            strategy.order("TP1 Short", strategy.long, qty=qty_to_exit, comment="TP1 Exit")
            short_remaining_size := math.abs(strategy.position_size) - qty_to_exit
            label.new(bar_index, low, "TP1 HIT\n" + str.tostring(qty_to_exit, "#"), color=color.green, style=label.style_label_up, textcolor=color.white)
        
        // TP2 Check
        if short_tp1_hit and not short_tp2_hit and low <= short_tp2_price
            short_tp2_hit := true
            qty_to_exit = math.abs(strategy.position_size) * tp2_percentage
            strategy.order("TP2 Short", strategy.long, qty=qty_to_exit, comment="TP2 Exit")
            short_remaining_size := math.abs(strategy.position_size) - qty_to_exit
            label.new(bar_index, low, "TP2 HIT\n" + str.tostring(qty_to_exit, "#"), color=color.green, style=label.style_label_up, textcolor=color.white)
        
        // TP3 Check
        if short_tp2_hit and not short_tp3_hit and low <= short_tp3_price
            short_tp3_hit := true
            qty_to_exit = math.abs(strategy.position_size) * tp3_percentage
            strategy.order("TP3 Short", strategy.long, qty=qty_to_exit, comment="TP3 Exit")
            short_remaining_size := math.abs(strategy.position_size) - qty_to_exit
            label.new(bar_index, low, "TP3 HIT\n" + str.tostring(qty_to_exit, "#"), color=color.green, style=label.style_label_up, textcolor=color.white)

// === Corrected Rolling Sharpe Calculation ===
var float lastEquity = na
var float barReturn = na
equityNow = strategy.equity

if not na(lastEquity)
    barReturn := math.log(equityNow / lastEquity)

lastEquity := equityNow

// Rolling statistics
windowSize = 100
ret_mean = ta.sma(barReturn, windowSize)
ret_std = ta.stdev(barReturn, windowSize)

// Correct annualization factor
var float annualizationFactor = na
if na(annualizationFactor)
    tf_minutes = timeframe.in_seconds() / 60
    periods_per_year = switch
        tf_minutes == 1   => 525600
        tf_minutes == 5   => 105120
        tf_minutes == 15  => 35040
        tf_minutes == 30  => 17520
        tf_minutes == 60  => 8760
        tf_minutes == 240 => 2190
        tf_minutes == 1440 => 365
        => 8760
    
    annualizationFactor := math.sqrt(periods_per_year)

// Corrected Sharpe Ratio calculation
rollingSharpe = if not na(barReturn) and not na(ret_std) and ret_std != 0 and bar_index >= windowSize
    annualizedReturn = ret_mean * annualizationFactor
    annualizedStd = ret_std * annualizationFactor
    sharpeRatio = annualizedStd != 0 ? (annualizedReturn - riskFreeRate) / annualizedStd : na
    math.max(-10, math.min(10, sharpeRatio))
else
    na

// === Use Built-in Metrics for Filtering ===
profitFactor = strategy.grossloss != 0 ? strategy.grossprofit / math.abs(strategy.grossloss) : na
maxDrawdown = strategy.max_drawdown

maxDrawdownIsQualified = math.abs(maxDrawdown) < (strategy.initial_capital * 0.10)

qualified = not na(rollingSharpe) and rollingSharpe > 1.5 and
     not na(profitFactor) and profitFactor > 1.5 and
     maxDrawdownIsQualified

plotshape(qualified, title="Qualified Strategy", location=location.top, style=shape.labelup, color=color.green, text="✔")

// === NEW: Tiered TP Validation Warning ===
plotshape(tp_validation_error, title="Tiered TP Error", location=location.bottom, style=shape.labeldown, color=color.red, text="TP % ≠ 100%")

// === NEW: Position Status Display ===
if barstate.islast
    var table positionTable = table.new(position.top_left, 4, 3, bgcolor=color.new(color.white, 80), border_width=1)
    
    table.cell(positionTable, 0, 0, "Position", text_color=color.black, bgcolor=color.gray)
    table.cell(positionTable, 1, 0, "Status", text_color=color.black, bgcolor=color.gray)  
    table.cell(positionTable, 2, 0, "Alert ID", text_color=color.black, bgcolor=color.gray)
    table.cell(positionTable, 3, 0, "Tiered TP", text_color=color.black, bgcolor=color.gray)
    
    table.cell(positionTable, 0, 1, "Long", text_color=color.black)
    table.cell(positionTable, 1, 1, longPositionOpen ? "OPEN" : "CLOSED", 
               text_color=longPositionOpen ? color.green : color.red)
    table.cell(positionTable, 2, 1, na(currentLongAlertId) ? "None" : str.substring(currentLongAlertId, 0, 12) + "...", 
               text_color=color.black)
    table.cell(positionTable, 3, 1, longPositionOpen and useTieredTP ? 
               "TP1:" + (long_tp1_hit ? "✓" : "○") + " TP2:" + (long_tp2_hit ? "✓" : "○") + " TP3:" + (long_tp3_hit ? "✓" : "○") : 
               "N/A", text_color=color.black)
    
    table.cell(positionTable, 0, 2, "Short", text_color=color.black)
    table.cell(positionTable, 1, 2, shortPositionOpen ? "OPEN" : "CLOSED", 
               text_color=shortPositionOpen ? color.green : color.red)
    table.cell(positionTable, 2, 2, na(currentShortAlertId) ? "None" : str.substring(currentShortAlertId, 0, 12) + "...", 
               text_color=color.black)
    table.cell(positionTable, 3, 2, shortPositionOpen and useTieredTP ? 
               "TP1:" + (short_tp1_hit ? "✓" : "○") + " TP2:" + (short_tp2_hit ? "✓" : "○") + " TP3:" + (short_tp3_hit ? "✓" : "○") : 
               "N/A", text_color=color.black)

// === Optimized Status Display ===
showTable = barstate.islast or (bar_index > windowSize and bar_index % 50 == 0)

if showTable
    // MODIFIED: Increased rows from 4 to 6 (including signal debug)
    var table statusTable = table.new(position.bottom_right, 2, 6, bgcolor=color.new(color.white, 80), border_width=1)
    
    // CORRECTED: The table.clear syntax was slightly off. This now correctly clears the value column for all 6 rows.
    table.clear(statusTable, 1, 1, 0, 5)
    
    // Cached metrics for display
    currentSharpe = na(rollingSharpe) ? 0.0 : rollingSharpe
    currentProfitFactor = na(profitFactor) ? 0.0 : profitFactor
    pnlDDRatio = maxDrawdown != 0 ? strategy.netprofit / math.abs(maxDrawdown) : na
    currentPnlDD = na(pnlDDRatio) ? 0.0 : pnlDDRatio
    
    // Status
    overallPass = qualified
    statusColor = overallPass ? color.green : color.red
    
    // Row 0: Status
    table.cell(statusTable, 0, 0, "STATUS", text_color=color.white, text_size=size.normal, bgcolor=color.new(color.gray, 50))
    table.cell(statusTable, 1, 0, overallPass ? "PASS" : "FAIL", text_color=color.white, text_size=size.normal, bgcolor=statusColor)
    
    // Row 1: P&L/DD
    table.cell(statusTable, 0, 1, "P&L/DD", text_color=color.white, text_size=size.normal)
    table.cell(statusTable, 1, 1, str.tostring(currentPnlDD, "#.##"), text_color=color.white, text_size=size.normal)

    // Row 2: Sharpe Ratio
    table.cell(statusTable, 0, 2, "Sharpe", text_color=color.white, text_size=size.normal)
    table.cell(statusTable, 1, 2, str.tostring(currentSharpe, "#.##"), text_color=color.white, text_size=size.normal)
    
    // Row 3: Profit Factor
    table.cell(statusTable, 0, 3, "Profit Factor", text_color=color.white, text_size=size.normal)
    table.cell(statusTable, 1, 3, str.tostring(currentProfitFactor, "#.##"), text_color=color.white, text_size=size.normal)

    // NEW ROW: Row 4: Early Flips
    table.cell(statusTable, 0, 4, "Early Flips", text_color=color.white, text_size=size.normal)
    table.cell(statusTable, 1, 4, str.tostring(totalEarlyFlips), text_color=color.white, text_size=size.normal)
    
    // === NEW: Signal Debug Information ===
    table.cell(statusTable, 0, 5, "Signal Debug", text_color=color.white, text_size=size.normal)
    signalDebug = "Src:" + str.tostring(src, "#.##") + " | Type:" + str.tostring(signalType) + " | Alert:" + str.tostring(alertId)
    table.cell(statusTable, 1, 5, signalDebug, text_color=color.white, text_size=size.normal)