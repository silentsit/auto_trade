// This source code is subject to the terms of the Mozilla Public License 2.0 at https://mozilla.org/MPL/2.0/
// © jdehorty
//@version=5
strategy("Backtest Adapter with Bot Exit Logic", overlay=true, default_qty_type=strategy.percent_of_equity, default_qty_value=100)

// ==== Backtest Time Period ====
useDateFilter = input.bool(true, title="Begin Backtest at Start Date", group="Backtest Time Period")
backtestStartDate = input.time(timestamp("11 May 2022"), title="Start Date", group="Backtest Time Period")
inTradeWindow = not useDateFilter or time >= backtestStartDate

// ==== Source Input ====
src = input.source(title="Source", defval=close, tooltip="Source of the input data", group="General Settings")

// ==== Bot Exit Logic Settings ====
enableBotExitLogic = input.bool(true, title="Enable Bot Exit Logic", group="Bot Exit Settings")
atrLength = input.int(14, title="ATR Length", group="Bot Exit Settings")
atrMultiplier = input.float(2.0, title="ATR Multiplier for SL/TP", group="Bot Exit Settings")
riskRewardRatio = input.float(2.0, title="Risk:Reward Ratio", group="Bot Exit Settings")
enableProfitOverride = input.bool(true, title="Enable Profit Override", group="Bot Exit Settings")
profitOverrideThreshold = input.float(1.0, title="Profit Override Threshold (R)", group="Bot Exit Settings")
trailingStopATRMultiplier = input.float(2.0, title="Trailing Stop ATR Multiplier", group="Bot Exit Settings")
maxRideTimeHours = input.int(48, title="Max Ride Time (hours)", group="Bot Exit Settings")

// ==== Performance Display Settings ====
showBacktestStatus = input.bool(true, "Show Status Table", group="Performance")
reportEveryN = input.int(1, "Report update every N bars", minval=1, maxval=10, group="Performance")

// ==== Sharpe Calculation Settings ====
rollingDays = input.int(126, "Rolling Window (days) for Daily Sharpe", minval=60, group="Sharpe Settings")
devMode = input.bool(true, "Development Mode (smaller windows)", group="Performance")
devRollingDays = devMode ? 50 : rollingDays

// Date window & throttles
bool inWindow = inTradeWindow or barstate.isrealtime
bool liteTick = barstate.isrealtime or (bar_index % reportEveryN == 0)

// ==== Bot Exit Logic Variables ====
var float entryPrice = na
var float stopLossPrice = na
var float takeProfitPrice = na
var float trailingStopPrice = na
var bool profitOverrideActive = false
var bool breakevenEnabled = false
var float breakevenPrice = na
var float initialRiskAmount = na
var datetime entryTime = na
var string positionSide = na

// Early flips tracking
var int totalEarlyFlips = 0
var string lastSignal = na

// ==== Performance Variables ====
var float rollingSharpeBar = na
var float profitFactor = na
var float maxDrawdown = na
var float pnlDDRatio = na
var bool qualified = false

// Sharpe caching variables
var float cachedRollingSharpeBar = na
var int lastSharpeUpdate = 0

// ==== ATR Calculation ====
atr = ta.atr(atrLength)

// ==== Bot Exit Logic Functions ====
calculateSLTP(price, side, atrVal, multiplier, rrRatio) =>
    slDistance = atrVal * multiplier
    if side == "LONG"
        sl = price - slDistance
        tp = price + (slDistance * rrRatio)
    else
        sl = price + slDistance
        tp = price - (slDistance * rrRatio)
    [sl, tp]

activateProfitOverride(currentPrice, side, atrVal, multiplier) =>
    if side == "LONG"
        newTrailingStop = currentPrice - (atrVal * multiplier)
    else
        newTrailingStop = currentPrice + (atrVal * multiplier)
    newTrailingStop

updateTrailingStop(currentPrice, side, atrVal, multiplier) =>
    if not profitOverrideActive
        na
    else
        if side == "LONG"
            newTrailingStop = currentPrice - (atrVal * multiplier)
            // Apply breakeven if enabled
            if breakevenEnabled and breakevenPrice > newTrailingStop
                newTrailingStop := breakevenPrice
            // Only move trailing stop up
            if newTrailingStop > trailingStopPrice
                newTrailingStop
            else
                trailingStopPrice
        else
            newTrailingStop = currentPrice + (atrVal * multiplier)
            // Apply breakeven if enabled
            if breakevenEnabled and breakevenPrice < newTrailingStop
                newTrailingStop := breakevenPrice
            // Only move trailing stop down
            if newTrailingStop < trailingStopPrice
                newTrailingStop
            else
                trailingStopPrice

checkBreakevenActivation(currentPrice) =>
    if not breakevenEnabled and currentPrice >= entryPrice + initialRiskAmount
        true
    else
        false

// ==== Entry and Exit Conditions ====
startLongTrade = src == 1
endLongTrade = src == 2
startShortTrade = src == -1
endShortTrade = src == -2

// ==== Bot Exit Logic Implementation ====
if enableBotExitLogic and strategy.position_size != 0
    currentPrice = close
    currentTime = time
    
    // Check if position is too old
    positionAge = (currentTime - entryTime) / (1000 * 60 * 60) // Convert to hours
    if positionAge > maxRideTimeHours
        if strategy.position_size > 0
            strategy.close("Long", comment="Max Ride Time Exceeded")
        else
            strategy.close("Short", comment="Max Ride Time Exceeded")
    
    // Check breakeven activation
    if checkBreakevenActivation(currentPrice)
        breakevenEnabled := true
        breakevenPrice := entryPrice
    
    // Update trailing stop if profit override is active
    if profitOverrideActive
        newTrailingStop = updateTrailingStop(currentPrice, positionSide, atr, trailingStopATRMultiplier)
        if not na(newTrailingStop)
            trailingStopPrice := newTrailingStop
        
        // Check if trailing stop was hit
        if positionSide == "LONG" and currentPrice <= trailingStopPrice
            strategy.close("Long", comment="Trailing Stop Hit")
        else if positionSide == "SHORT" and currentPrice >= trailingStopPrice
            strategy.close("Short", comment="Trailing Stop Hit")
    
    // Check initial SL/TP if profit override is not active
    if not profitOverrideActive
        if positionSide == "LONG"
            if currentPrice <= stopLossPrice
                strategy.close("Long", comment="Stop Loss Hit")
            else if currentPrice >= takeProfitPrice
                strategy.close("Long", comment="Take Profit Hit")
        else if positionSide == "SHORT"
            if currentPrice >= stopLossPrice
                strategy.close("Short", comment="Stop Loss Hit")
            else if currentPrice <= takeProfitPrice
                strategy.close("Short", comment="Take Profit Hit")

// ==== Entry Logic ====
if startLongTrade and inTradeWindow and strategy.position_size == 0
    strategy.order("Enter Long", strategy.long)
    entryPrice := close
    entryTime := time
    positionSide := "LONG"
    [sl, tp] = calculateSLTP(close, "LONG", atr, atrMultiplier, riskRewardRatio)
    stopLossPrice := sl
    takeProfitPrice := tp
    initialRiskAmount := abs(close - sl)
    profitOverrideActive := false
    breakevenEnabled := false
    trailingStopPrice := na

if startShortTrade and inTradeWindow and strategy.position_size == 0
    strategy.order("Enter Short", strategy.short)
    entryPrice := close
    entryTime := time
    positionSide := "SHORT"
    [sl, tp] = calculateSLTP(close, "SHORT", atr, atrMultiplier, riskRewardRatio)
    stopLossPrice := sl
    takeProfitPrice := tp
    initialRiskAmount := abs(close - sl)
    profitOverrideActive := false
    breakevenEnabled := false
    trailingStopPrice := na

// ==== Close Signal Logic (Bot's Override Analysis) ====
if enableBotExitLogic and enableProfitOverride
    // Analyze close signal for override eligibility
    if (endLongTrade and strategy.position_size > 0) or (endShortTrade and strategy.position_size < 0)
        currentPrice = close
        positionAge = (time - entryTime) / (1000 * 60 * 60) // Convert to hours
        
        // Check if override should be activated
        currentProfit = abs(currentPrice - entryPrice)
        profitFactor = currentProfit / initialRiskAmount
        
        // Override eligibility criteria (simplified version of bot's logic)
        shouldOverride = false
        overrideReason = ""
        
        // Profit factor check
        if profitFactor >= profitOverrideThreshold
            shouldOverride := true
            overrideReason := "Profit threshold met"
        
        // Position age check
        if positionAge > maxRideTimeHours
            shouldOverride := false
            overrideReason := "Position too old"
        
        if shouldOverride and not profitOverrideActive
            // Activate profit override
            profitOverrideActive := true
            trailingStopPrice := activateProfitOverride(currentPrice, positionSide, atr, trailingStopATRMultiplier)
            // In real bot, this would remove SL/TP from broker
            // For backtest, we just mark them as inactive
        else if not shouldOverride
            // Execute close signal immediately
            if endLongTrade and strategy.position_size > 0
                strategy.close("Long", comment="Close Signal Executed")
            else if endShortTrade and strategy.position_size < 0
                strategy.close("Short", comment="Close Signal Executed")
    else
        // Handle close signals when bot exit logic is disabled
        if endLongTrade and strategy.position_size > 0 and inTradeWindow
            strategy.close("Long", comment="Close Signal")
        if endShortTrade and strategy.position_size < 0 and inTradeWindow
            strategy.close("Short", comment="Close Signal")
else
    // Original simple exit logic when bot exit logic is disabled
    if endLongTrade and strategy.position_size > 0 and inTradeWindow
        strategy.close("Long", comment="Close Signal")
    if endShortTrade and strategy.position_size < 0 and inTradeWindow
        strategy.close("Short", comment="Close Signal")

// ==== Position Reset on Exit ====
if strategy.position_size == 0
    entryPrice := na
    stopLossPrice := na
    takeProfitPrice := na
    trailingStopPrice := na
    profitOverrideActive := false
    breakevenEnabled := false
    breakevenPrice := na
    initialRiskAmount := na
    entryTime := na
    positionSide := na

// ===== Early Flips Tracking =====
if inWindow
    string currentSignal = na
    if startLongTrade
        currentSignal := "LONG_ENTRY"
    else if startShortTrade
        currentSignal := "SHORT_ENTRY"
    else if endLongTrade or endShortTrade
        currentSignal := "CLOSE"
    
    if not na(currentSignal) and currentSignal != "CLOSE"
        if not na(lastSignal) and lastSignal != currentSignal
            totalEarlyFlips += 1
        lastSignal := currentSignal
    else if currentSignal == "CLOSE"
        lastSignal := na

// ===== Sharpe Calculation (Daily) =====
riskFreeRate = 0.04

if inWindow
    // Daily Sharpe ring buffer
    var int dayCap = rollingDays
    var float[] dayBuf = array.new_float(dayCap, na)
    var int dayHead = 0
    var int dayCount = 0
    var float daySum = 0.0
    var float daySum2 = 0.0
    var float lastDailyEquity = na
    
    if dayCap != devRollingDays and liteTick
        dayCap := devRollingDays
        dayBuf := array.new_float(dayCap, na)
        dayHead := 0
        dayCount := 0
        daySum := 0.0
        daySum2 := 0.0
        lastDailyEquity := na
    
    bool newDay = time("D") != time("D")[1]
    if newDay
        eqNow = strategy.equity
        if na(lastDailyEquity)
            lastDailyEquity := eqNow
        else if lastDailyEquity > 0
            rd = (eqNow - lastDailyEquity) / lastDailyEquity
            float old = array.get(dayBuf, dayHead)
            if not na(old)
                daySum -= old
                daySum2 -= old * old
            else
                dayCount += 1
            array.set(dayBuf, dayHead, rd)
            daySum += rd
            daySum2 += rd * rd
            dayHead := (dayHead + 1) % dayCap
            lastDailyEquity := eqNow
    
    // Sharpe caching & throttling
    bool shouldUpdateSharpe = (bar_index - lastSharpeUpdate >= 10) or (strategy.position_size != strategy.position_size[1]) or barstate.islast
    if shouldUpdateSharpe
        lastSharpeUpdate := bar_index

        // Daily Sharpe
        if dayCount > 5
            mean_d = daySum / dayCount
            var_d = math.max(daySum2 - dayCount * mean_d * mean_d, 0) / math.max(dayCount - 1, 1)
            std_d = math.sqrt(var_d)
            cachedRollingSharpeBar := std_d > 0 ? (mean_d * 252) / (std_d * math.sqrt(252)) : na

    // Use cached values
    rollingSharpeBar := cachedRollingSharpeBar

    // Built-in stats for table
    profitFactor := strategy.grossloss != 0 ? strategy.grossprofit / math.abs(strategy.grossloss) : na
    maxDrawdown := strategy.max_drawdown
    pnlDDRatio := maxDrawdown != 0 ? strategy.netprofit / math.abs(maxDrawdown) : na

    dailySharpePass = not na(rollingSharpeBar) and rollingSharpeBar >= 1.2
    profitFactorPass = not na(profitFactor) and profitFactor >= 1.5
    pnlDDPass = not na(pnlDDRatio) and pnlDDRatio >= 1.5
    qualified := dailySharpePass and profitFactorPass and pnlDDPass

// ===================
// ==== Status Table ====
bt_init_table() =>
    table.new(position=position.bottom_left, columns=2, rows=8,
              bgcolor=color.new(color.white, 80), border_width=1,
              frame_color=color.new(color.black, 0), frame_width=1, border_color=color.new(color.black, 0))

bt_update_table(tbl) =>
    totalTrades_pine = strategy.closedtrades
    totalWins_pine = strategy.wintrades
    netPnL_pine = strategy.netprofit
    maxDD_pine = strategy.max_drawdown
    grossProfit_pine = strategy.grossprofit
    grossLoss_pine = strategy.grossloss
    winRate_pine = totalTrades_pine > 0 ? (totalWins_pine / totalTrades_pine) * 100 : 0
    profitFactor_pine = grossLoss_pine != 0 ? math.abs(grossProfit_pine / grossLoss_pine) : na
    pnlDD_pine = maxDD_pine != 0 ? netPnL_pine / math.abs(maxDD_pine) : na
    hasActivity = totalTrades_pine > 0 or netPnL_pine != 0 or strategy.position_size != 0
    string statusText = hasActivity ? "RUNNING" : "WAITING"
    
    // Bot exit logic status
    string exitStatus = enableBotExitLogic ? "BOT EXIT" : "SIMPLE EXIT"
    if enableBotExitLogic and profitOverrideActive
        exitStatus := "TRAILING"
    
    // Institutional-grade status color logic
    color statusBgColor = #808080  // Default gray for WAITING
    if hasActivity
        bool qualifiedStrategy = not na(pnlDD_pine) and pnlDD_pine >= 1.5 and not na(rollingSharpeBar) and rollingSharpeBar >= 1.2
        if qualifiedStrategy
            statusBgColor := #00FF00     // Green: Institutional quality (P&L/DD ≥ 1.5 AND Sharpe ≥ 1.2)
        else if netPnL_pine >= 0
            statusBgColor := #FF8C00     // Bright Orange: Profitable but not qualified
        else
            statusBgColor := #FF0000     // Red: In drawdown
    
    table.clear(tbl, 0, 0, 1, 7)
    
    // STATUS row
    table.cell(tbl, 0, 0, "STATUS", text_color=#FFFFFF, text_size=size.normal, bgcolor=#404040)
    table.cell(tbl, 1, 0, statusText, text_color=#FFFFFF, text_size=size.normal, bgcolor=statusBgColor)
    
    // EXIT LOGIC row
    table.cell(tbl, 0, 1, "EXIT LOGIC", text_color=#FFFFFF, text_size=size.normal, bgcolor=#404040)
    table.cell(tbl, 1, 1, exitStatus, text_color=#FFFFFF, text_size=size.normal, bgcolor=#0066CC)
    
    // Row 2: P&L/Max DD (white background, black font)
    table.cell(tbl, 0, 2, "P&L/Max DD", text_color=#000000, text_size=size.normal, bgcolor=#FFFFFF)
    table.cell(tbl, 1, 2, na(pnlDD_pine) ? "---" : str.tostring(pnlDD_pine, "#.##"), text_color=#000000, text_size=size.normal, bgcolor=#FFFFFF)
    
    // Row 3: Sharpe (white background, black font)
    table.cell(tbl, 0, 3, "Sharpe", text_color=#000000, text_size=size.normal, bgcolor=#FFFFFF)
    table.cell(tbl, 1, 3, na(rollingSharpeBar) ? "---" : str.tostring(rollingSharpeBar, "#.##"), text_color=#000000, text_size=size.normal, bgcolor=#FFFFFF)
    
    // Row 4: Profit Factor (white background, black font)
    table.cell(tbl, 0, 4, "Profit Factor", text_color=#000000, text_size=size.normal, bgcolor=#FFFFFF)
    table.cell(tbl, 1, 4, na(profitFactor_pine) ? "---" : str.tostring(profitFactor_pine, "#.##"), text_color=#000000, text_size=size.normal, bgcolor=#FFFFFF)
    
    // Row 5: Trades (blue background, white font)
    table.cell(tbl, 0, 5, "Trades", text_color=#FFFFFF, text_size=size.normal, bgcolor=#404040)
    table.cell(tbl, 1, 5, str.tostring(totalTrades_pine), text_color=#FFFFFF, text_size=size.normal, bgcolor=#0066CC)
    
    // Row 6: Win Rate (blue background, white font)
    table.cell(tbl, 0, 6, "Win Rate", text_color=#FFFFFF, text_size=size.normal, bgcolor=#404040)
    table.cell(tbl, 1, 6, str.tostring(winRate_pine, "#.##") + "% (" + str.tostring(totalWins_pine) + "/" + str.tostring(totalTrades_pine) + ")", text_color=#FFFFFF, text_size=size.normal, bgcolor=#0066CC)
    
    // Row 7: Early Flips (blue background, white font)
    table.cell(tbl, 0, 7, "Early Flips", text_color=#FFFFFF, text_size=size.normal, bgcolor=#404040)
    table.cell(tbl, 1, 7, str.tostring(totalEarlyFlips, "#"), text_color=#FFFFFF, text_size=size.normal, bgcolor=#0066CC)

// -------- Status table throttling
var table tbl = na
var int lastTableUpdate = 0
if showBacktestStatus and inWindow
    if na(tbl)
        tbl := bt_init_table()
    bool shouldUpdateTable = barstate.isconfirmed and (barstate.islast or strategy.position_size != strategy.position_size[1] or bar_index - lastTableUpdate >= 20)
    if shouldUpdateTable
        lastTableUpdate := bar_index
        bt_update_table(tbl)

// ==== Plotting ====
plot(entryPrice, "Entry Price", color=color.blue, linewidth=2)
plot(stopLossPrice, "Stop Loss", color=color.red, linewidth=1)
plot(takeProfitPrice, "Take Profit", color=color.green, linewidth=1)
plot(trailingStopPrice, "Trailing Stop", color=color.orange, linewidth=2, style=plot.style_stepline)
plot(breakevenPrice, "Breakeven", color=color.yellow, linewidth=1, style=plot.style_stepline)
